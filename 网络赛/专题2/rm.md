# 2018年7月28日 

　
> ## Problem B — 简单计算器 

> ### 题意：读入一个只包含 +, -, *, / 的非负整数计算表达式，计算该表达式的值。       

> ### 思路：乱搞思路，首先用string读入，用两个栈逆着读入（这样对于栈顶操作就是顺着了），一个存所有的操作数，一个存所有的操作符。然后再借助另外两个队列，对于操作符栈中 * 和 / 操作都先进行了，如果是+，-操作那么就放入操作符队列中，即扫一遍完成所有的 * ，/操作，然后再对于两个队列中剩下的加减操作顺序进行。

　
> ## Problem C — Team Queue

> ### 题意：十分难读，大意是给了几个原始的队列，每个队列各自是一个team，然后让你新建一个队列进行入队出队操作，入队操作是如果这个数在队列中有队友（也就是说这个数存在的原始队列中的其他元素出现过）那么他就能在他队友后面，如果没有队友那么他就只能站在最后。出队操作就是这个队列队首出队。       

> ### 思路：如果把原始队列搞下来然后搜肯定超时，有个巧妙的做法，首先应该不会有一个数在两个原始队列中，那么就可以人为编号，以原始队列输入的次序1-n，不去记录原始队列，而用一个`map<int,int> mp`value表示key这个数所属的队列标号。进行操作时，利用一个队列Q和一个队列数组q[i]，队列Q表示入队元素标号排序，q[i]记录每个入队的元素。

　
> ## Problem D — Binary Tree Traversals

> ### 题意：给前序和中序求后序。       

> ### 思路：貌似不用还原整颗二叉树，递归算法，按前序顺序访问各个节点当作当前根节点，然后在中序序列中找到该根节点的位置，该位置左边为左子树，右边为右子树不断递归，最后输出。